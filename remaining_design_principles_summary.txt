1) command

ordinary statements are perishable , cannot be undone or redone
cannot serialize a series of actions (call)
cannot reoo / rollback series of operations
need something that can represent an operation + record (who + what)
useful for a post-hoc analysis
something like a gui tool would use this, multi level undo - redo of ops 
macro recording uses something similar

so : 

An object that reprents an instruction to perform a particular action, contains all the information necessary,
for the action to be taken


2) interpreter

used to process textual input 
turn text into oop for ex; interpreters, compilers, html, xml, numeric expressions, regex
compiler theory - topic in compiler construction course

so: 
interpreter process structured text data
tokenizes (lexing)
then parses these tokens

3) iterator

core functionality of various data structures 
it is a class which facilitates the traversal 
keeps reference to current element and knows how to move to the next element 
needs __iter__ which uses  __next__  , or both 
raise stopiteration when done 

4) mediator

facilitates communication between components
like a chat room where people can come in / out
no point in keeping references between compiler
mediator helps in communication without being aware or having references to participating components
chat room is a good ex

typically mediator set while initialization
engage in bidirectional communication 


5) memento

return a snapshot ( memento ) of mutation of state to return to that specific
point in time
useful for undo redo, and can return placeholder like None to represent failed state change and hence refuse request
can keep track of the mementos in list to undo redo if memory not an issue and clear in time 

6) observer

need to be informed when certain things happen
ex : object property changes, object does something, some external events occur
listen to events, notify when they occur 
unsubscribe from events when no longer interested 

observer observes observable (often through the generation of events from observable) 

7) state

changes in state can be explicit or be in response to an event 
object's behavior is determinded by it's state
object needs to transition from one state to another 
to manage state formally we need what is callled a FSM

think always about these when designing : 

entry exit conditions
action for transition  (trigger)
guard conditions enabling blocking of transition
default action when no transitions are found for an event 

8) strategy

many alogrithms can be composed into higher + lower level parts 
high level part can be used to make different things but remains same like a series of steps
low level implementation might change
at runtime you specify the details, then that component uses its high level approach wiht your low level strategy to do stuff

9) template method

strategy does composition and we need to pass strategy instance to perform the implementation
template method does the same thing using inheritance

overall algo implemented in base class
inheritors override the abstract mebers
template method is invoked to get the work done

10) visitor

define a new operation on an entire class hierarchy
need access to the non common aspects of the class hierarchy
create an external component to handle the rendering 

visitor is a component that can traverse a structure composed of (maybe related) types

11) summary 

simple summary for all the patterns : 

1) creational: 
    builder : complicated object with several calls made , 
    can make several sub-builders that are fluent, to chain

    factory:  unique name, more expressive than initializer
    can be standalone class or an innerclass abstract factories

    prototype: make object not from scratch, make deep copy (recursive)
    prototype factory can be done also  

    singelton : decorator / metaclass to ensure single instance exists 
    can use dependency injection

2) structural 
    adapter : one interface to adapt to another
    bridge : decouple abstraction from implementation
    composite : ind, obj compositons uniformly
    decorator : python one is different from custom implementation, or add additonal resp to objects
    facade : single unified interface over set of interfaces
    flyweight : effeciently support large numbers of similar objects
    proxy : surrogate object that forwards the calls to the real one

3) behavioral
    chain of responsibility : allow components to process info in a chain 
    command : encapsulate request into a separate object (CQS)
    interpreter : transform textual input to object oriented structures
    iterator : interface to access elements of an aggregate object , __iter__ , __next__ , can use yield for more imperative and clean implementations
    mediator : provides mediation between 2 pbjects 
    memento : tokens representing the system state , good to rollback or go back to a state when the memento was made and returned 
    obsever : allows notifications of change in the state of the observed (maybe a component / class )
    state : model systems by having a set of states and model transitions 
    startegy method : some skeleton where high level details of algo are defined, subparts are taken as params
    template : same thing as strategy but little better since it uses abstract base class and inheritance
    visitor : allows a non intrusive additon of functionality to hieracrchies and help traverse ( maybe to collect info or make decisions ) 
    of complex interconnected data structures

