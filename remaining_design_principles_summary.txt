1) command

ordinary statements are perishable , cannot be undone or redone
cannot serialize a series of actions (call)
cannot reoo / rollback series of operations
need something that can represent an operation + record (who + what)
useful for a post-hoc analysis
something like a gui tool would use this, multi level undo - redo of ops 
macro recording uses something similar

so : 

An object that reprents an instruction to perform a particular action, contains all the information necessary,
for the action to be taken


2) interpreter

used to process textual input 
turn text into oop for ex; interpreters, compilers, html, xml, numeric expressions, regex
compiler theory - topic in compiler construction course

so: 
interpreter process structured text data
tokenizes (lexing)
then parses these tokens

3) iterator

core functionality of various data structures 
it is a class which facilitates the traversal 
keeps reference to current element and knows how to move to the next element 
needs __iter__ which uses  __next__  , or both 
raise stopiteration when done 

4) mediator

facilitates communication between components
like a chat room where people can come in / out
no point in keeping references between compiler
mediator helps in communication without being aware or having references to participating components
chat room is a good ex

typically mediator set while initialization
engage in bidirectional communication 


5) memento

return a snapshot ( memento ) of mutation of state to return to that specific
point in time
useful for undo redo, and can return placeholder like None to represent failed state change and hence refuse request
can keep track of the mementos in list to undo redo if memory not an issue and clear in time 

6) observer

need to be informed when certain things happen
ex : object property changes, object does something, some external events occur
listen to events, notify when they occur 
unsubscribe from events when no longer interested 

observer observes observable (often through the generation of events from observable) 

7) state

changes in state can be explicit or be in response to an event 
object's behavior is determinded by it's state
object needs to transition from one state to another 
to manage state formally we need what is callled a FSM

think always about these when designing : 

entry exit conditions
action for transition  (trigger)
guard conditions enabling blocking of transition
default action when no transitions are found for an event 

8) strategy

many alogrithms can be composed into higher + lower level parts 
high level part can be used to make different things but remains same like a series of steps
low level implementation might change
at runtime you specify the details, then that component uses its high level approach wiht your low level strategy to do stuff

9) template method

strategy does composition and we need to pass strategy instance to perform the implementation
template method does the same thing using inheritance

overall algo implemented in base class
inheritors override the abstract mebers
template method is invoked to get the work done

10) visitor

11) summary 